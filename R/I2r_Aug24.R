### R-HTA in LMICs Workshop 
## Introduction to R for HTA Modelling
##
## 30 August 2024 
##
## Buhle Ndweni
## Joshua Soboil
##
####################################

## R basics 

##How to assign óbjects' values
x <- 2 #object 'x' is assigned the value 2 (<- or = is the assignment operator)
# R will now remember that x=2

## If you want R to recall your assigned object 
print(x)

##---------------------------------------------

## VECTORS 

##Vectors are simple data structures (grouping similar things together)

length(x) #Use this 'base' r function to see the length of object 'x' (numeric vector)

## Use of concatenate 'c()' function to assign several ordered values to a single object:
x <- c(5, 3, 1, 5.2, 2.45, 10.4, 9, 2.2) #basic (atomic) vectors
##IMPORTANT: This must be the SAME type of data
print(x) #this will recall the value associated with object 'x'
#Alternatively just type 'x' into the Rscript:
x


##----------------------------------------------

## LOGICAL VECTORS (generated by conditions; values are: TRUE, FALSE and NA ['not available'])

## Example: Create object 'v'and assign values between 1 to 10 
v <- sample(x = c(1:10), size = 5, replace = TRUE)
length(x) == length(v) ## Q: Are the lengths of object 'x' and object 'v' EQUAL? 
length(x) != length(v) #Q: Are the lengths of object 'x' and object 'v' NOT EQUAL?

# Q: is the length of object x greater than/less than/greater or equal to/less than or
# equal to object v?
length(x) > length(v) #greater than
length(x) < length(v) #lesser than 
length(x) >= length(v) #greater or equal to
length(x) <= length(v) # Lesser or equal to 

##------------------------------------------------------------------------------

## LISTS (Type of vector that stores any type of value)

## Lists won't force your values into a single data type
## Lists are like an object 'filing cabinet' with multiple objects stored systematically 
list_rhta <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
list_rhta

##-----------------------------------------------------------------------------

## MANIPULATING OBJECTS (objects now stored in R memory)

# Example: manipulation of object x from earlier)
1/x


x # Only one value is lesser or equal to 1 (<=1)

#Like a 'filing cabinet' R uses 'indexing' to 'access' the elements of an object
x[x<=1] #our condition gives us the expected result

# How to access a specific value in object x:
x[3]

#How to access 3rd, 4th and 5th values of object x: 
x[c(3, 4, 5)] #remember this concatenate 'c()' function from earlier is used to 
#specify multiple functions 

##--------------------------------------

## Vectorisation (Vector arithmetic)

# Recall object x from R memory (no need to run the code, very useful 
# when dealing with lots of code)
y <- (1 / x) * cos(pi)
matrix(data = y, nrow = 4) #this matrix function is used for a neat look

# Matrix function avoids the need for loops, assuming the object lengths are the same
#and the new object 'y' was introduced and assigned same object 'x' dimensional characteristics . 
# What happens when the object lengths differ? 9e.g: product of x and shorter object of z)

z <- c(1, 2, 3)# create object
x * z # product of x * z?
## R only multiplies the first 3 values (while vectorisation is a short cut, be careful as 
#thought must be given to what you want to achieve and the objects to be used). 
# Importance of understanding working with 'for loops' in R to resolve this x * Z issue. 

##-----------------------------------------

## For Loops (iterated over an index sequence)
# 'for loops'are used extensively for Markov modelling since these use matrices
#
for (name in expr_1) expr_2 #repeatedly evaluates object expr_2 as name ranges (‘loops’) through
# the values in the vector result of expr_1. 
#
## Create matrix object with `x` rows and `z` columns
g <- matrix(data = NA, nrow = length(x), ncol = length(z))
# iterate over the rows and columns, multiplying all the values of `x` with the j'th column of `z`. 
# This means that the whole vector of `x` is multiplied by a single value of `z` 
# until all values of `z` of been iterated over `x`.
for (i in 1:length(x)) {
  for (j in 1:length(z)) {
    g[i, j] <- x[i] * z[j]
  }
}

print(z)

x[1] # first for loop indexes x, so we start with the first value of x...

# multiply x[1] by the first value of z
x[1] * z[1] 

# by the second value of z
x[1] * z[2]

# and then the third value of z
x[1] * z[3]

# which is the same as the first column of 'g' from the for loop
g[1, ]


## then the second value of x...

x[2]
# multiply x[2] by the first value of z

x[2] * z[1]
# by the second value of z

x[2] * z[2]
# and then the third value of z

x[2] * z[3]
# which is the same as the second column of g from the for loop
g[2, ]

## Continue until you have looped through each value of x multiplied by each value of z

# Do these match the corresponding values of the matrix?
# There is an even simpler solution! Back to vectorised operations. Since vectorised operations
# work element-wise on matrices, we can manipulate x into a matrix object and then multiply by z
x_matrix <- matrix(data = x, nrow = length(x), ncol = length(z))
# and then, et voila!

x_matrix * z

##-------------------------------------

# MATRIX MULTIPLICATION 

# create matrix
matrix_temp <- matrix(data = rnorm(n = 10*5, mean = 0, sd = 1),
                      nrow = 10, ncol = 5)
# print results
matrix_temp

# create a vector of values:
vector_eg <- runif(n = 5, min = 0, max = 1)

# create object to store output
output_temp <- matrix(data = NA, nrow = 10, ncol = 5)

# iterate for-loop over nrows by ncols
for (i in 1:nrow((matrix_temp))) {
  output_temp[i, ] <- matrix_temp[i, ] %*% vector_eg
}





