---
title: "A Brief Introduction to R: 2024 Tutorial"
author: "R-HTA in LMICs"
format: pdf
toc: true
toc-depth: 3
urlcolor: blue
editor: source
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Load libraries
library(tidyr)
library(ggplot2)
# Set plot theme
theme_set(theme_minimal())
```

**\
Note:** this basic introduction to R is derived from the freely available [An Introduction to R](https://cran.r-project.org/manuals.html) document on the CRAN website.

\newpage

# R: understanding what's going on 'under-the-R-hood'

In a general sense, the R language centres on assigning 'objects' specific 'values'. Although this is not entirely accurate, it is okay to think of what R does to remember objects in that way. For example:

```{r assigning objects, include = TRUE, echo = TRUE}
# here we assign the numeric value 2 to the object 'x'
x <- 2
```

Note the assignment operator `<-`, i.e., it is the thing that assigns the value to the object. You can also use `=` sign like in Excel or Python - it doesn't make a difference and it is completely up to personal preference! But, what you are essentially doing is telling `R` to remember that the value `2` is associated with the object `x`. So, whenever you call `x`, this means you are asking `R` to please recall the object and interpret the data or instructions that were assigned to that object:

```{r recalling assigned objects, include = TRUE, echo = TRUE}
# so, we call `x`, and now every time we do that, the computer 
# tells us that this `object` has a numeric value of 2.
x
```

You can also explicity ask R to recall the object using the `print()` function:

```{r printing assigned objects, include = TRUE, echo = TRUE}
print(x)
```
\newpage

# Vectors

So, R operates on named *data structures*. Structures can be thought of as a group of 'things' - these 'things' can be similar or different. A simple data structure is a vector, which groups things of the same kind. For example, a collection of numbers, e.g., 1, 2, 3, 4, and so on. Such a data structure with a single number value is called a numeric vector in `R`. A numeric vector is a single entity (think 'object' like `x` above) consisting of a collection of *ordered* numbers. The mathematical analogy is a 'set'. Hence, we can think of the above code as assigning an *ordered collection of numbers* with length $1$ to `x`.

```{r length x, include = TRUE, echo = TRUE}
# we can see the length of x using the following 'base' r function:
length(x)
```

To expand on the above, we can assign *several* ordered values to a single object using the *concatenate* function:

```{r concatanate x, include = TRUE, echo = TRUE}
x <- c(5, 3, 1, 5.2, 2.45, 10.4, 9, 2.2)
# and by calling the object we can see what values are associated with that
# object:
print(x)
# or simply
x
```

**However:** when using basic vectors using the `c()` function, it is very important to use the same type of data. If you use numeric values as well as string (character) values in a single *atomic* vector (i.e., vectors created using `c()`), this will coerce, i.e., force, values to change to a single type. For example, when using a string and a numeric type in a vector, the vector will become a string vector and `R` will no longer recognise any values as numeric:

```{r coercion, include = TRUE, echo = TRUE, error = TRUE}
temp <- c(1, 2, "4", 5, "3 31")
temp * 2
```

The above warning is telling us that we no longer have numeric values in our vector!
\newpage

# Logical Vectors

`R` also allows manipulation of logical values. The elements of a logical vector can have the values `TRUE`, `FALSE`, and `NA` (for “not available”). Logical vectors are generated by conditions. For instance, using the previous example, we can see if the length of `x` is the same of `x`:

```{r logic example, include = TRUE, echo = TRUE}
# here we are just creating an object v and assigning values between 1:10
# randomly, using the base sample() function:
v <- sample(x = c(1:10), size = 5, replace = TRUE)
# are the lengths of x and v equal?
length(x) == length(v)
# are the lengths of x and v not equal? (in R we use != operator 
# to identifying whether an object or value is not equal to another)
length(x) != length(v)
# is the length of v greater than/less than/greater or equal to/less than or
# equal to v? (in R we use >, <, >=, <=, like in maths) 
length(x) > length(v)
length(x) < length(v)
length(x) >= length(v)
length(x) <= length(v)
```
\newpage
# Lists
Lists are a type of vector. However, unlike basic vectors (referred to as atomic vectors in `R`), Lists - created using the `list()` function in `R` - can store any type of values. So, unlike atomic vectors using the `c()` function, Lists will not coerce your values to a single data type:

```{r lists, include = TRUE, echo = TRUE}
list_example <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
list_example
```

You can intuitively think of a list as an object storing multiple objects. A list is like a neat file cabinet, where you can store many different things in each drawer and still access each drawer without letting the contents becoming mixed up.
\newpage

# Manipulating Objects

Once we have objects stored in the computer's memory, we can manipulate all the values we assigned to a object. For instance, let's manipulate the values assigned to `x` above:

```{r calculate inverse x, include = TRUE, echo = TRUE}
1/x
```

Here, we are simply saying take each value and make it $\frac{1}{x}$.

We can also mix this with logical operators to assign values which are $\leq 1$, for example:

```{r geq x, include = TRUE, echo = TRUE}
x # there's only 1 value <= 1...
x[x <= 1] # and our condition returns what we expect...
```

Note how the above example uses 'indexing'. Indexing is a way of 'accessing' the elements of an object. For instance, if we wanted to access specific values in the object `x`, we do the following:

```{r indexing, include = TRUE, echo = TRUE}
# the third value of x:
x[3]
# the third, fourth, and fifth value of x:
x[c(3, 4, 5)]
# ... and note the concatenate function to specify multiple values!
```

However, see how in both examples we did not assign the output values to a *new* object and so the outputs are *not* stored in memory. We cannot recall the result without rerunning the code! Every time we want specific values from a specific object, which we performed an operation on, we have to carefully remember where the code is in our project. This isn't very helpful!

This may not seem like a problem here but it is much easier to assign values to objects when we are dealing with large models which include matrices and arrays, like Markov models. Assigning large outputs with thousands of values to single objects is much easier to work with. You can think of it like storing a table of data in an Excel spreadsheet. But, instead of always having it visible, you tell `R` when it access it when it is needed - one of the many reasons `R` is so much more efficient than Excel.

\newpage

# Vectorisation
Now that we have a basic understanding of objects and vectors in `R` we are going to learn how to utilise *vector arithmetic*. The neat thing is that shorter vectors in the expression are recycled until they match the length of the longest vector. So, let's set up the following simple equation,

$$
y_{i} = \frac{1}{x_{i}} \times cos(\pi)
$$ and note that $\cos(\pi)$ is a single value. Let's translate it into `R`:

```{r vector arithmetic, include = TRUE, echo = TRUE}
y <- (1 / x) * cos(pi)
# and now that we have an object stored in memory, we can recall it without
# running the code (which is very handy when we have lots of code!). Note, the
# matrix function is being here to just make it look neat. We will touch on
# matrix operations shortly.
matrix(data = y, nrow = 4)
```

While this makes life a lot easier, and avoids the need for `for loops`, there is a disadvantage.

**Observe** how we don't have to be explicit that the object `x` has several values. In other words, we don't have to *explicitly* iterate over `x_{i}`. In this case, it worked as intended as each value in `x` was multiplied by `cos(pi)`. However, it is *very* important to make sure that both objects have the same length. Again, in the example above it was acceptable to vectorise this calculation since we assigned values to a *new* object and so the new object `y` was assigned the same dimensional characteristics of `x`! But, what happens if we take the product of `x` and a shorter object `z`?

```{r vectorisation example, include = TRUE, echo = TRUE}
# create object
z <- c(1, 2, 3)
# product of x * z?
x * z
```

*R only multiplies the first three values*!. So, be very careful. Vectorisation is much more efficient but you must think about what you are trying to achieve and the objects you are working with applying these short cuts. This is why understanding how to work with `for loops` in `R` is important.

\newpage

# For Loops
Very simply speaking. `for loops` are used to iterate over an index sequence. First consider the form of a `for loop` below:

`for (name in expr_1) expr_2`

The `for loop` above repeatedly evaluates the object `expr_2` as `name` ranges ('loops') through the values in the vector result of `expr_1`. We can use a `for loop` to resolve the `x` $\times$ `z` issue discussed above.

```{r using fl and apply, include = TRUE, echo = TRUE}
# we first create a matrix object with `x` rows and `z` columns
g <- matrix(data = NA, nrow = length(x), ncol = length(z))
# then we iterate over the rows and columns, multiplying all the values of `x`
# with the j'th column of `z`. This means that the whole vector of `x` is
# multiplied by a single value of `z` until all values of `z` of been iterated
# over `x`.
for (i in 1:length(x)) {
 for (j in 1:length(z)) {
  g[i, j] <- x[i] * z[j]
 }
}
```

It is important to know that `for loops` are used extensively for Markov modelling, since Markov models use matrices!

To get an intuitive feel for `for loop`'s, you can try it for yourself iteratively multiplying `x` by a value of `z`. This will help get a sense of how the operation is taking place inside the for loop. Note how `x` is the *outer* loop and `z` is the *inner* loop, i.e., you multiply each value of `x` with every value of `z` before moving to the next `x` value in the sequence. For example:

```{r x times z, include = TRUE, echo = TRUE}
print(z)
# the first for loop indexes x, so we start with the first value of x...
x[1]
# multiply x[1]...
# by the first value of z
x[1] * z[1]
# by the second value of z
x[1] * z[2]
# and then the third value of z
x[1] * z[3]
# which is the same as the first column of g from the for loop
g[1, ]

# then the second value of x...
x[2]
# multiply x[2]...
# by the first value of z
x[2] * z[1]
# by the second value of z
x[2] * z[2]
# and then the third value of z
x[2] * z[3]
# which is the same as the second column of g from the for loop
g[2, ]

# and so on, until you have looped through each value of 
# x multiplied by each value of z!
```

Do these match the corresponding values of the matrix?

*There is an even simpler solution*! Back to vectorised operations. Since vectorised operations work element-wise on matrices, we can manipulate `x` into a matrix object and then multiply by `z`

```{r x-matrix times z, include = TRUE, echo = TRUE}
x_matrix <- matrix(data = x, nrow = length(x), ncol = length(z))
# and then, et voila!
x_matrix * z
```

Again, it is still very important to make sure that your data are being manipulated as intended.

\newpage

# Matrix Multiplication

Lastly, we will cover matrix multiplication in `R`. For those who don't know a matrix is a rectangular array or table of numbers, symbols, or expressions, arranged in rows and columns, which is used to represent a mathematical object or a property of such an object. Have you worked with a Markov model in Excel? Well, the structure of the model is just a matrix in spreadsheet form!

Let's create a matrix of samples and see what happens when we multiply it be a set of values for each column:

```{r matrix multiplication, include = TRUE, echo = TRUE}
# create matrix
matrix_temp <- matrix(data = rnorm(n = 10*5, mean = 0, sd = 1),
                      nrow = 10, ncol = 5)
# print results
matrix_temp
# create a vector of values:
vector_eg <- runif(n = 5, min = 0, max = 1)
# create object to store output
output_temp <- matrix(data = NA, nrow = 10, ncol = 5)
# iterate for-loop over nrows by ncols
for (i in 1:nrow((matrix_temp))) {
 output_temp[i, ] <- matrix_temp[i, ] %*% vector_eg
}
```

Have fun coding!
